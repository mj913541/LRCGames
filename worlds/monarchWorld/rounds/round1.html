<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>‚öîÔ∏è Monarch World | Round 1 Battles</title>

  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

  <style>
    body {
      background: radial-gradient(circle at 20% 10%, #fff7ed, #fef3c7 35%, #dcfce7 100%);
      min-height: 100vh;
      font-family: ui-sans-serif, system-ui;
    }
    .card {
      background: rgba(255,255,255,0.95);
      border-radius: 24px;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 12px 30px rgba(0,0,0,0.1);
    }
    .arena {
      border-radius: 24px;
      border: 2px dashed rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.82);
      padding: 16px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-bottom: 12px;
    }
    .bookBtn {
      border-radius: 20px;
      font-weight: 900;
      padding: 14px;
      width: 100%;
      transition: transform 0.08s ease, filter 0.15s ease;
    }
    .bookBtn:active { transform: scale(0.98); }
    .locked { opacity: 0.55; cursor: not-allowed; }
    .muted { opacity: 0.72; }
    .success {
      background: rgba(34,197,94,0.12) !important;
      border: 2px solid rgba(34,197,94,0.35);
    }
    .chosen { outline: 4px solid rgba(34,197,94,0.35); }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      font-weight: 900;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.10);
      background: rgba(255,255,255,0.85);
    }
    video {
      width: 100%;
      border-radius: 20px;
      background: #000;
      border: 2px solid rgba(0,0,0,0.1);
    }
  </style>
</head>

<body>
  <div class="max-w-6xl mx-auto p-4 md:p-6">

    <!-- HEADER -->
    <div class="card p-4 md:p-6 mb-4">
      <div class="flex justify-between items-center gap-3 flex-wrap">
        <div>
          <div class="text-2xl md:text-3xl font-extrabold">‚öîÔ∏è Round 1: Battle Arena</div>
          <div class="text-sm opacity-80 mt-1">
            Rule: Watch BOTH book videos all the way to the end, then vote for the winner.
          </div>
        </div>
        <a href="../monarchWorld.html"
           class="px-4 py-3 rounded-2xl font-extrabold bg-white border hover:bg-gray-50">
          ‚Üê Map
        </a>
      </div>

      <div class="mt-3 flex items-center justify-between gap-3 flex-wrap">
        <div id="progressText" class="text-sm font-bold"></div>
        <div id="status" class="text-sm font-bold opacity-80"></div>
      </div>
    </div>

    <!-- VIDEO ZONE -->
    <div class="card p-4 md:p-6 mb-4">
      <div class="flex items-center justify-between gap-3 flex-wrap">
        <div>
          <div class="font-extrabold text-lg">üé• Watch Zone</div>
          <div id="nowPlaying" class="font-bold opacity-80">Choose a book to watch</div>
          <div id="watchNeed" class="mt-1 text-sm font-bold opacity-70">
            Watch both books in a battle to unlock voting.
          </div>
        </div>
        <div class="tag" id="watchTag">üîí Not watched</div>
      </div>

      <div class="mt-3">
        <video id="video" controls preload="metadata"></video>
      </div>

      <div class="mt-2 text-sm font-bold opacity-70">
        Tip: When the video ends, it counts as watched ‚úÖ
      </div>
    </div>

    <!-- MATCHUPS -->
    <div id="matches" class="grid md:grid-cols-2 gap-4"></div>
  </div>

  <!-- ‚úÖ EVERYTHING AS A MODULE + IMPORT YOUR CORE -->
  <script type="module">
import {
  requireLogin,
  getLocalProgress,
  saveProgress
} from "../../../scripts/lrcQuestCore.js";

    const SEASON = "2026";
    const ROUND_ID = "r1";

    const MATCHUPS = [
      ["Mr. S: A First Day of School Book", "Negative Cat"],
      ["Yoshi, Sea Turtle Genius", "Sydney and Taylor Explore the Whole Wide World"],
      ["Knight Owl", "Beneath"],
      ["Thunder and Cluck: Friends Do Not Eat Friends", "We Are Definitely Human"],
      ["The Red Jacket", "Hamsters Make Terrible Roommates"],
      ["The Flower Garden", "Butt or Face?: A Hilarious Animal Guessing Game for Kids"],
      ["Time to Make Art", "Bathe the Cat"],
      ["Who‚Äôs Afraid of the Light?", "Just SNOW Already!"],
      ["Home is Calling: The Journey of the Monarch Butterfly", "The World‚Äôs Best Class Plant"],
      ["Claude: The True Story of a White Alligator", "Homegrown"]
    ];

    const VIDEO_BASE = "../videos/2026/";
    const VIDEO_FILES = {
      "Mr. S: A First Day of School Book": "mr-s.mp4",
      "Negative Cat": "negative-cat.mp4",
      "Yoshi, Sea Turtle Genius": "yoshi-sea-turtle-genius.mp4",
      "Sydney and Taylor Explore the Whole Wide World": "sydney-and-taylor-explore-the-whole-wide-world.mp4",
      "Knight Owl": "knight-owl.mp4",
      "Beneath": "beneath.mp4",
      "Thunder and Cluck: Friends Do Not Eat Friends": "thunder-and-cluck-friends-do-not-eat-friends.mp4",
      "We Are Definitely Human": "we-are-definitely-human.mp4",
      "The Red Jacket": "the-red-jacket.mp4",
      "Hamsters Make Terrible Roommates": "hamsters-make-terrible-roommates.mp4",
      "The Flower Garden": "the-flower-garden.mp4",
      "Butt or Face?: A Hilarious Animal Guessing Game for Kids": "butt-or-face.mp4",
      "Time to Make Art": "time-to-make-art.mp4",
      "Bathe the Cat": "bathe-the-cat.mp4",
      "Who‚Äôs Afraid of the Light?": "whos-afraid-of-the-light.mp4",
      "Just SNOW Already!": "just-snow-already.mp4",
      "Home is Calling: The Journey of the Monarch Butterfly": "home-is-calling-the-journey-of-the-monarch-butterfly.mp4",
      "The World‚Äôs Best Class Plant": "the-worlds-best-class-plant.mp4",
      "Claude: The True Story of a White Alligator": "claude-the-true-story-of-a-white-alligator.mp4",
      "Homegrown": "homegrown.mp4"
    };

    // -----------------------------
    // Progress shape stored inside lrcQuest progress object:
    // progress.monarchWorld[SEASON].r1 = { watched: { m0:{title:true...} }, votes:{ m0:"title" } }
    // -----------------------------
    function getRoundState() {
      const p = getLocalProgress() || {};
      p.monarchWorld = p.monarchWorld || {};
      p.monarchWorld[SEASON] = p.monarchWorld[SEASON] || {};
      p.monarchWorld[SEASON][ROUND_ID] = p.monarchWorld[SEASON][ROUND_ID] || { watched: {}, votes: {} };
      return p;
    }

    function setStatus(msg) { document.getElementById("status").textContent = msg || ""; }
    function setWatchTag(msg) { document.getElementById("watchTag").textContent = msg || ""; }

    const ui = {
      matchCards: {}, // i -> { card, watchBtnsByTitle, voteBtnsByTitle, miniStatusEl }
      watchedMap: {}, // i -> { [title]: true }
      voteMap: {}     // i -> votedTitle
    };

    let currentMatch = null;
    let currentTitle = null;

    function setProgressText() {
      const total = MATCHUPS.length;
      const done = Object.keys(ui.voteMap).length;
      document.getElementById("progressText").textContent = `Battles completed: ${done} / ${total}`;
    }

    function watchedBoth(matchIndex) {
      const watched = ui.watchedMap[matchIndex] || {};
      const [a,b] = MATCHUPS[matchIndex];
      return !!(watched[a] && watched[b]);
    }

    function updateMiniStatus(matchIndex) {
      const group = ui.matchCards[matchIndex];
      if (!group) return;

      const voted = !!ui.voteMap[matchIndex];
      const [a,b] = MATCHUPS[matchIndex];
      const watched = ui.watchedMap[matchIndex] || {};
      const count = (watched[a] ? 1 : 0) + (watched[b] ? 1 : 0);

      if (voted) return (group.miniStatusEl.textContent = "‚úÖ Voted!");
      group.miniStatusEl.textContent =
        count === 0 ? "Watch both books: 0/2" :
        count === 1 ? "Watch both books: 1/2" :
                      "‚úÖ Watched both! Vote unlocked!";
    }

    function unlockVotes(matchIndex) {
      const group = ui.matchCards[matchIndex];
      if (!group || ui.voteMap[matchIndex]) return;

      Object.entries(group.voteBtnsByTitle).forEach(([title, btn]) => {
        btn.disabled = false;
        btn.classList.remove("locked");
        btn.classList.add("success");
        btn.textContent = `üó≥Ô∏è Vote for "${title}"`;
      });
    }

    function relockVotes(matchIndex) {
      const group = ui.matchCards[matchIndex];
      if (!group || ui.voteMap[matchIndex]) return;

      Object.values(group.voteBtnsByTitle).forEach(btn => {
        btn.disabled = true;
        btn.classList.add("locked");
        btn.classList.remove("success");
        btn.textContent = "üîí Vote";
      });
    }

    function lockMatchAfterVote(matchIndex, votedTitle) {
      const group = ui.matchCards[matchIndex];
      if (!group) return;

      Object.values(group.voteBtnsByTitle).forEach(btn => {
        btn.disabled = true;
        btn.classList.add("locked", "muted");
        btn.classList.remove("success");
      });

      const chosenBtn = group.voteBtnsByTitle[votedTitle];
      if (chosenBtn) {
        chosenBtn.textContent = `‚úÖ WINNER: "${votedTitle}"`;
        chosenBtn.classList.remove("muted");
        chosenBtn.classList.add("chosen");
      }
      Object.keys(group.voteBtnsByTitle).forEach(t => {
        if (t !== votedTitle) group.voteBtnsByTitle[t].textContent = "‚Äî";
      });

      group.card.classList.add("success");
      updateMiniStatus(matchIndex);
    }

    async function persistWatched(matchIndex) {
      await saveProgress((progress) => {
        progress = progress || {};
        progress.monarchWorld = progress.monarchWorld || {};
        progress.monarchWorld[SEASON] = progress.monarchWorld[SEASON] || {};
        const r = progress.monarchWorld[SEASON][ROUND_ID] || { watched: {}, votes: {} };

        r.watched = r.watched || {};
        r.watched[`m${matchIndex}`] = ui.watchedMap[matchIndex] || {};

        progress.monarchWorld[SEASON][ROUND_ID] = r;
        return progress;
      });
    }

    async function persistVote(matchIndex, title) {
      await saveProgress((progress) => {
        progress = progress || {};
        progress.monarchWorld = progress.monarchWorld || {};
        progress.monarchWorld[SEASON] = progress.monarchWorld[SEASON] || {};
        const r = progress.monarchWorld[SEASON][ROUND_ID] || { watched: {}, votes: {} };

        r.votes = r.votes || {};
        r.votes[`m${matchIndex}`] = title;

        progress.monarchWorld[SEASON][ROUND_ID] = r;
        return progress;
      });
    }

    function loadFromLocalProgress() {
      const p = getRoundState();
      const r = p.monarchWorld[SEASON][ROUND_ID];

      ui.watchedMap = {};
      ui.voteMap = {};

      const watched = r.watched || {};
      const votes = r.votes || {};

      for (let i=0;i<MATCHUPS.length;i++) {
        ui.watchedMap[i] = watched[`m${i}`] || {};
        if (votes[`m${i}`]) ui.voteMap[i] = votes[`m${i}`];
      }
    }

    function loadVideoFor(matchIndex, title) {
      if (!VIDEO_FILES[title]) {
        setStatus(`‚ö†Ô∏è Missing video filename for: ${title}`);
        return;
      }

      currentMatch = matchIndex;
      currentTitle = title;

      const video = document.getElementById("video");
      video.pause();
      video.currentTime = 0;
      video.src = VIDEO_BASE + VIDEO_FILES[title];
      video.load();

      document.getElementById("nowPlaying").textContent =
        `Now watching: ${title} (Battle ${matchIndex + 1})`;

      const watched = !!(ui.watchedMap[matchIndex] && ui.watchedMap[matchIndex][title]);
      setWatchTag(watched ? "‚úÖ Watched (already)" : "üîí Not watched");

      if (ui.voteMap[matchIndex]) {
        setStatus("This battle is already voted. You can still watch videos!");
      } else if (watchedBoth(matchIndex)) {
        setStatus("‚úÖ Both watched already ‚Äî vote is unlocked!");
        unlockVotes(matchIndex);
      } else {
        setStatus("Watch BOTH book videos to unlock voting.");
        relockVotes(matchIndex);
      }
    }

    function render() {
      const host = document.getElementById("matches");
      host.innerHTML = "";
      ui.matchCards = {};

      MATCHUPS.forEach((pair, idx) => {
        const card = document.createElement("div");
        card.className = "arena";

        const header = document.createElement("div");
        header.className = "flex items-center justify-between mb-3";
        header.innerHTML = `
          <div class="font-extrabold text-lg">Battle ${idx + 1}</div>
          <div class="tag">${ui.voteMap[idx] ? "‚úÖ Done" : "‚≠ê In Progress"}</div>
        `;
        card.appendChild(header);

        const miniStatus = document.createElement("div");
        miniStatus.className = "text-sm font-bold opacity-80 mb-2";
        card.appendChild(miniStatus);

        const wrap = document.createElement("div");
        wrap.className = "row";

        const watchBtnsByTitle = {};
        const voteBtnsByTitle = {};

        pair.forEach((bookTitle) => {
          const block = document.createElement("div");
          block.className = "p-3 rounded-2xl border bg-white";

          const name = document.createElement("div");
          name.className = "font-extrabold";
          name.textContent = bookTitle;

          const watchedAlready = !!(ui.watchedMap[idx] && ui.watchedMap[idx][bookTitle]);

          const watchBtn = document.createElement("button");
          watchBtn.className = "bookBtn bg-blue-500 hover:bg-blue-600 text-white mt-3";
          watchBtn.textContent = watchedAlready ? `üé• Watch (‚úÖ watched)` : `üé• Watch`;
          watchBtn.addEventListener("click", () => loadVideoFor(idx, bookTitle));
          watchBtnsByTitle[bookTitle] = watchBtn;

          const voteBtn = document.createElement("button");
          voteBtn.className = "bookBtn bg-green-500 text-white mt-2 locked";
          voteBtn.disabled = true;
          voteBtn.textContent = "üîí Vote";

          voteBtn.addEventListener("click", async () => {
            if (ui.voteMap[idx]) return;

            if (!watchedBoth(idx)) {
              setStatus("üîí Watch BOTH books in this battle before voting!");
              return;
            }

            ui.voteMap[idx] = bookTitle;
            await persistVote(idx, bookTitle);

            lockMatchAfterVote(idx, bookTitle);
            setProgressText();

            if (Object.keys(ui.voteMap).length === MATCHUPS.length) {
              await completeRound();
            } else {
              setStatus("‚úÖ Vote saved! Go to the next battle!");
            }
          });

          voteBtnsByTitle[bookTitle] = voteBtn;

          block.appendChild(name);
          block.appendChild(watchBtn);
          block.appendChild(voteBtn);
          wrap.appendChild(block);
        });

        card.appendChild(wrap);
        host.appendChild(card);

        ui.matchCards[idx] = { card, watchBtnsByTitle, voteBtnsByTitle, miniStatusEl: miniStatus };

        if (ui.voteMap[idx]) {
          lockMatchAfterVote(idx, ui.voteMap[idx]);
        } else {
          updateMiniStatus(idx);
          if (watchedBoth(idx)) unlockVotes(idx);
          else relockVotes(idx);
        }
      });

      setProgressText();
    }

    async function completeRound() {
      await saveProgress((progress) => {
        progress = progress || {};
        progress.monarchWorld = progress.monarchWorld || {};
        progress.monarchWorld[SEASON] = progress.monarchWorld[SEASON] || {};
        progress.monarchWorld[SEASON].map = progress.monarchWorld[SEASON].map || {
          unlocked: { r1: true, r2: false, r3: false, rf: false, win: false },
          completed: { r1: false, r2: false, r3: false, rf: false, win: false }
        };

        progress.monarchWorld[SEASON].map.completed.r1 = true;
        progress.monarchWorld[SEASON].map.unlocked.r2 = true;

        return progress;
      });

      alert("üéâ Round 1 Complete! You unlocked the next stepping stone!");
      window.location.href = "../monarchWorld.html";
    }

    function boot() {
      requireLogin(async () => {
        loadFromLocalProgress();
        render();
        setStatus("Pick a battle. Watch BOTH books. Then vote!");
      });
    }

    document.getElementById("video").addEventListener("ended", async () => {
      if (currentMatch === null || !currentTitle) return;

      ui.watchedMap[currentMatch] = ui.watchedMap[currentMatch] || {};
      ui.watchedMap[currentMatch][currentTitle] = true;

      await persistWatched(currentMatch);

      const watchBtn = ui.matchCards[currentMatch]?.watchBtnsByTitle?.[currentTitle];
      if (watchBtn) watchBtn.textContent = "üé• Watch (‚úÖ watched)";

      updateMiniStatus(currentMatch);

      if (watchedBoth(currentMatch)) {
        setWatchTag("‚úÖ Watched ‚Äî BOTH done!");
        unlockVotes(currentMatch);
        setStatus("‚úÖ You watched BOTH books! Now vote for the winner!");
      } else {
        setWatchTag("‚úÖ Watched (one done)");
        setStatus("üëç Nice! Now watch the OTHER book in this battle.");
      }
    });

    boot();
  </script>
</body>
</html>
