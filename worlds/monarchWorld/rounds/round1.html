<!-- worlds/monarchWorld/rounds/round1.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ü™® AB Monarch World | Round 1 Path</title>

  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../styles/monarch.css">
  <link rel="stylesheet" href="../styles/animations.css">

  <style>
    body{
      background: url("../assets/backgrounds/night-forest.png") center / cover no-repeat fixed;
    }

    /* --- Round 1 mini-map layout --- */
    .r1-mapWrap{
      position: relative;
      padding: 12px;
      padding-bottom: 90px; /* extra breathing room */
      border-radius: 0;
      background: transparent;
      border: none;
      backdrop-filter: none;
      box-shadow: none;
      overflow: hidden;
    }

    .r1-pathCanvas{
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.12;
      z-index: 1;
    }

    .r1-fireflies{
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 2;
      opacity: 0.65;
    }

    /* TALLER MAP */
    .r1-mapArea{
      position: relative;
      height: 1200px;
      z-index: 3;
    }

    @media (max-width: 640px){
      .r1-mapArea{ height: 1400px; }
    }

    .r1-stoneSlot{
      position: absolute;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0px;
    }

    /* --- Stone anchor ensures avatar aligns to the real stone --- */
    .r1-stoneAnchor{
      position: relative;
      width: max-content;
      height: max-content;
    }

    /* number badge */
    .r1-battleLabel{
      margin-top: -2px;  /* tighter + closer to stone */
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 38px;
      height: 38px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.14);
      background: rgba(255,255,255,0.90);
      font-size: 14px;
      font-weight: 1000;
      box-shadow: 0 10px 22px rgba(0,0,0,0.14);
      user-select: none;
      line-height: 1;
      position: relative;
    }

    /* optional: finish flag on #10 */
    .r1-battleLabel .r1-finishBadge{
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 16px;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.25));
      transform: rotate(8deg);
    }

    /* ----------------- Fireflies ----------------- */
    .r1-firefly{
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      box-shadow:
        0 0 10px rgba(255,255,255,0.55),
        0 0 22px rgba(251,191,36,0.25);
      opacity: 0.0;

      /* S-CURVE PATH (matches SVG below) */
      offset-path: path("M520,70 C820,150 820,280 520,350 C220,420 220,560 520,630 C820,700 820,840 520,920");
      offset-rotate: 0deg;

      animation:
        r1Fly var(--dur, 8s) linear infinite,
        r1Flicker 1.35s ease-in-out infinite;
      animation-delay: var(--delay, 0s), calc(var(--delay, 0s) * 0.25);
      filter: blur(0.2px);
    }

    @keyframes r1Fly{
      0%   { offset-distance: 0%;   opacity: 0; transform: scale(0.75); }
      8%   { opacity: 0.85; }
      50%  { opacity: 0.95; transform: scale(1); }
      92%  { opacity: 0.85; }
      100% { offset-distance: 100%; opacity: 0; transform: scale(0.75); }
    }

    @keyframes r1Flicker{
      0%,100% { transform: translateY(0) scale(1); opacity: 0.9; }
      50%     { transform: translateY(-2px) scale(0.95); opacity: 0.55; }
    }

    @supports not (offset-path: path("M0,0 L1,1")) {
      .r1-fireflies{ display:none; }
    }

    /* ----------------- OPTION A: Locked stones are NOT grayed out ----------------- */
    .mw-stepStone--locked,
    .mw-stepStone--locked *,
    .mw-stepStone.locked,
    .mw-stepStone.locked *,
    [data-state="locked"],
    [data-state="locked"] *{
      opacity: 1 !important;
      filter: none !important;
      -webkit-filter: none !important;
      pointer-events: auto !important; /* allow click to show message */
    }

    /* locked-but-tempting ring */
    .r1-stoneSlot.isLocked{
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.18));
    }
    .r1-stoneSlot.isLocked .r1-battleLabel{
      box-shadow: 0 0 0 3px rgba(255,255,255,0.25), 0 10px 22px rgba(0,0,0,0.14);
    }

    /* next unlocked stone glow */
    .r1-stoneSlot.isNext{
      animation: r1NextPulse 1.6s ease-in-out infinite;
    }
    @keyframes r1NextPulse{
      0%,100% { filter: drop-shadow(0 0 0 rgba(251,191,36,0.0)) drop-shadow(0 14px 18px rgba(0,0,0,0.18)); }
      50%     { filter: drop-shadow(0 0 18px rgba(251,191,36,0.38)) drop-shadow(0 18px 26px rgba(0,0,0,0.22)); }
    }

    /* ----------------- Moving Avatar marker ----------------- */
    .r1-avatar{
      position: absolute;
      z-index: 6; /* above stones + labels */
      width: 56px;
      height: 56px;
      transform: translate(-50%, -75%); /* tuned so it sits above the stone */
      pointer-events: none;
      transition: left 520ms var(--mw-ease-pop, ease), top 520ms var(--mw-ease-pop, ease);
      filter: drop-shadow(0 14px 18px rgba(0,0,0,0.35));
    }
    .r1-avatar img{
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* ----------------- Battle Arena Modal ----------------- */
    .r1-modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.58);
      z-index: 80;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
    }
    .r1-modalBack.isOpen{ display:flex; }

    .r1-modal{
      width: min(1100px, 98vw);
      max-height: min(92vh, 920px);
      border-radius: 24px;
      background: rgba(255,255,255,0.93);
      border: 1px solid rgba(0,0,0,0.10);
      backdrop-filter: blur(10px);
      box-shadow: 0 24px 70px rgba(0,0,0,0.30);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }

    .r1-modalHead{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 14px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      flex: 0 0 auto;
    }

    .r1-modalBody{
      padding: 12px 14px 14px;
      overflow: auto;
      flex: 1 1 auto;
    }

    .r1-closeBtn{
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.90);
      border-radius: 999px;
      padding: 8px 10px;
      font-weight: 900;
      box-shadow: 0 8px 18px rgba(0,0,0,0.10);
      user-select:none;
      line-height: 1;
    }
    .r1-closeBtn:hover{ transform: translateY(-1px); }

    .r1-hint{
      font-weight: 900;
      font-size: 13px;
      opacity: 0.85;
    }

    .r1-topVsRow{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: stretch;
    }

    @media (min-width: 900px){
      .r1-topVsRow{
        grid-template-columns: 1fr auto 1fr;
        gap: 14px;
        align-items: stretch;
      }
    }

    /* VS is text (not a pill) */
    .r1-vsPill{
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 1000;
      letter-spacing: 0.14em;
      user-select:none;

      padding: 0;
      border: none;
      background: transparent;
      box-shadow: none;
      border-radius: 0;

      font-size: 26px;
      opacity: 0.95;
      text-shadow: 0 2px 10px rgba(0,0,0,0.25);
      min-width: 52px;
    }

    .r1-bioCard{
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 20px;
      background: rgba(255,255,255,0.78);
      box-shadow: 0 12px 26px rgba(0,0,0,0.10);
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
      min-height: 140px;
    }

    .r1-bookTitle{
      font-weight: 1000;
      font-size: 14px;
      line-height: 1.25;
    }

    .r1-btnRow{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .r1-videoSection{
      margin-top: 6px;
    }

    .r1-videoSection .mw-video{
      max-height: 50vh;
    }

    /* ----------------- Avatar Picker Cards ----------------- */
    .r1-avatarCard{
      border: 1px solid rgba(0,0,0,0.10);
      background: rgba(255,255,255,0.78);
      border-radius: 18px;
      padding: 12px;
      text-align: center;
      box-shadow: 0 12px 26px rgba(0,0,0,0.10);
      cursor: pointer;
      user-select: none;
    }
    .r1-avatarCard:hover{ transform: translateY(-2px); }
    .r1-avatarCard img{
      width: 64px;
      height: 64px;
      object-fit: contain;
      margin: 0 auto 8px;
    }
    .r1-avatarCard .name{
      font-weight: 900;
      font-size: 13px;
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <div class="mw-shell">

    <!-- HEADER -->
    <div class="mw-card mw-card--soft mw-section mw-animate-fade-up">
      <div class="mw-header">
        <div>
          <div class="mw-title">ü™® Round 1: Battle Path</div>
          <div class="mw-subtitle">
            Complete the battles IN ORDER. The next number will glow when it unlocks.
          </div>
        </div>

        <div class="flex items-center gap-2 flex-wrap">
          <button id="openAvatarBtn" class="mw-pill" type="button">üßë‚ÄçüöÄ Avatar</button>
          <a class="mw-pill" href="../monarchWorld.html">‚Üê Map</a>
        </div>
      </div>

      <div class="mw-row">
        <div id="progressText" class="mw-status"></div>
        <div id="status" class="mw-status"></div>
      </div>
    </div>

    <!-- MINI MAP -->
    <div class="r1-mapWrap mw-animate-fade-up">
      <div class="flex items-center justify-between gap-3 flex-wrap mb-3 relative" style="z-index:4;">
        <div class="font-extrabold text-lg text-white drop-shadow">üó∫Ô∏è Battle Path (In Order)</div>
        <div class="mw-tag" id="mapMiniStatus">Loading‚Ä¶</div>
      </div>

      <!-- S-CURVE PATH -->
      <svg class="r1-pathCanvas" id="pathSvg" viewBox="0 0 1000 1000" preserveAspectRatio="none" aria-hidden="true">
        <path
          id="pathBase"
          d="M520,70
             C820,150 820,280 520,350
             C220,420 220,560 520,630
             C820,700 820,840 520,920"
          fill="none"
          stroke="rgba(255,255,255,0.10)"
          stroke-width="10"
          stroke-linecap="round"
          stroke-dasharray="14 18"
        />
        <path
          d="M520,70
             C820,150 820,280 520,350
             C220,420 220,560 520,630
             C820,700 820,840 520,920"
          fill="none"
          stroke="rgba(251,191,36,0.025)"
          stroke-width="22"
          stroke-linecap="round"
        />
        <!-- progress highlight fill -->
        <path
          id="pathProgress"
          d="M520,70
             C820,150 820,280 520,350
             C220,420 220,560 520,630
             C820,700 820,840 520,920"
          fill="none"
          stroke="rgba(251,191,36,0.22)"
          stroke-width="10"
          stroke-linecap="round"
          stroke-dasharray="0 9999"
          stroke-dashoffset="0"
        />
      </svg>

      <div id="fireflies" class="r1-fireflies" aria-hidden="true"></div>

      <div id="battleMap" class="r1-mapArea"></div>

      <!-- Moving avatar marker -->
      <div id="pathAvatar" class="r1-avatar" aria-hidden="true">
        <img id="pathAvatarImg" alt="" />
      </div>

      <div class="mt-3 text-sm font-bold text-white drop-shadow relative" style="z-index:4;">
        ‚úÖ Completed = you already voted in that battle.
      </div>
    </div>
  </div>

  <!-- BATTLE ARENA MODAL -->
  <div id="arenaModalBack" class="r1-modalBack" role="dialog" aria-modal="true" aria-labelledby="arenaTitle">
    <div class="r1-modal" role="document">
      <div class="r1-modalHead">
        <div class="min-w-0">
          <div id="arenaTitle" class="font-extrabold text-lg">‚öîÔ∏è Battle Arena</div>
          <div id="arenaHint" class="r1-hint">Watch BOTH videos to unlock voting.</div>
          <div class="flex items-center gap-2 flex-wrap mt-2">
            <div class="mw-tag" id="watchTag">üîí Not watched</div>
            <div class="mw-tag" id="arenaLockTag">üîí Voting locked</div>
          </div>
        </div>
        <button id="closeArenaBtn" class="r1-closeBtn" type="button">‚úñ</button>
      </div>

      <div class="r1-modalBody">
        <!-- TOP: two books side-by-side with VS -->
        <div class="r1-topVsRow">
          <div class="r1-bioCard" id="bookCardA"></div>
          <div class="r1-vsPill">VS</div>
          <div class="r1-bioCard" id="bookCardB"></div>
        </div>

        <!-- BOTTOM: video player -->
        <div class="r1-videoSection mt-4">
          <div class="font-extrabold text-lg mb-1">üé• Watch Zone</div>
          <div id="nowPlaying" class="font-bold opacity-80">Choose a book to watch</div>

          <div class="mt-3">
            <video id="video" class="mw-video" controls preload="metadata"></video>
          </div>

          <div class="mt-2 text-sm font-bold opacity-70">
            When the video ends, it counts as watched ‚úÖ
          </div>
          <div id="watchNeed" class="mt-2 text-sm font-bold opacity-70">
            Watch both books in this battle to unlock voting.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- AVATAR PICKER MODAL -->
  <div id="avatarModalBack" class="r1-modalBack" role="dialog" aria-modal="true" aria-labelledby="avatarTitle">
    <div class="r1-modal" role="document" style="max-width: 760px;">
      <div class="r1-modalHead">
        <div class="min-w-0">
          <div id="avatarTitle" class="font-extrabold text-lg">üßë‚ÄçüöÄ Choose Your Avatar</div>
          <div class="r1-hint">Pick one ‚Äî it will move along the path as you unlock battles.</div>
        </div>
        <button id="closeAvatarBtn" class="r1-closeBtn" type="button">‚úñ</button>
      </div>

      <div class="r1-modalBody">
        <div id="avatarGrid" style="
          display:grid;
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
          gap: 14px;
        "></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { requireLogin, getLocalProgress, saveProgress } from "../../../scripts/lrcQuestCore.js";

    import { SEASON } from "../data/nominees-2026.js";
    import { ROUND1_MATCHUPS as MATCHUPS } from "../data/bracket-2026.js";
    import { getVideoUrl2026 } from "../data/video-map-2026.js";

    import { createStepStone } from "../components/stepStone.js";
    import { setProgressText as setProgressTextUI } from "../components/progressBar.js";
    import { attachVideoGate, getWatchedMap, hasWatchedBoth, hasWatched } from "../components/videoGate.js";
    import {
      getVoteMap,
      getVoteForMatch,
      isVoted,
      saveVote,
      applyVotedUI,
      unlockVoteUI,
      lockVoteUI
    } from "../components/voteLock.js";
    import { confettiBurst } from "../components/confetti.js";

    const ROUND_ID = "r1";

    const els = {
      status: document.getElementById("status"),
      progressText: document.getElementById("progressText"),
      mapMiniStatus: document.getElementById("mapMiniStatus"),
      battleMap: document.getElementById("battleMap"),
      fireflies: document.getElementById("fireflies"),

      // path progress
      pathBase: document.getElementById("pathBase"),
      pathProgress: document.getElementById("pathProgress"),

      // moving avatar
      pathAvatar: document.getElementById("pathAvatar"),
      pathAvatarImg: document.getElementById("pathAvatarImg"),

      // avatar picker
      openAvatarBtn: document.getElementById("openAvatarBtn"),
      avatarModalBack: document.getElementById("avatarModalBack"),
      closeAvatarBtn: document.getElementById("closeAvatarBtn"),
      avatarGrid: document.getElementById("avatarGrid"),

      // Arena modal
      arenaModalBack: document.getElementById("arenaModalBack"),
      closeArenaBtn: document.getElementById("closeArenaBtn"),
      arenaTitle: document.getElementById("arenaTitle"),
      arenaHint: document.getElementById("arenaHint"),
      arenaLockTag: document.getElementById("arenaLockTag"),

      bookCardA: document.getElementById("bookCardA"),
      bookCardB: document.getElementById("bookCardB"),

      nowPlaying: document.getElementById("nowPlaying"),
      watchNeed: document.getElementById("watchNeed"),
      watchTag: document.getElementById("watchTag"),

      video: document.getElementById("video"),
    };

    function setStatus(msg){ els.status.textContent = msg || ""; }
    function setWatchTag(msg){ els.watchTag.textContent = msg || ""; }
    function setArenaLockTag(msg){ els.arenaLockTag.textContent = msg || ""; }

    const ui = {
      watchedMap: {},
      voteMap: {},
      stones: [],
      voteBtnsByTitle: {},
      watchBtnsByTitle: {},
      pathLen: 0
    };

    let currentMatchIndex = null;
    let currentTitle = null;

    // Avatar options (place these PNGs in: worlds/monarchWorld/assets/avatars/)
    const AVATAR_OPTIONS = [
      { id: "lion",        name: "Lion",        src: "../assets/avatars/lion.png" },
      { id: "monarch",     name: "Monarch",     src: "../assets/avatars/monarch.png" },
      { id: "caterpillar", name: "Caterpillar", src: "../assets/avatars/caterpillar.png" },
      { id: "bear",        name: "Bear",        src: "../assets/avatars/bear.png" },
      { id: "book",        name: "Book",        src: "../assets/avatars/book.png" },
      { id: "owl",         name: "Owl",         src: "../assets/avatars/owl.png" }
    ];

    // SNAKE positions (extra bottom room so 8/9/10 don't smush)
    const STONE_POS = [
      { x: 52, y: 8  },   // 1
      { x: 74, y: 16 },   // 2
      { x: 62, y: 28 },   // 3
      { x: 36, y: 40 },   // 4
      { x: 44, y: 52 },   // 5
      { x: 72, y: 64 },   // 6
      { x: 60, y: 76 },   // 7
      { x: 36, y: 86 },   // 8
      { x: 58, y: 94 },   // 9
      { x: 52, y: 102 }   // 10 (slightly past 100% is OK)
    ];

    function voteCount(){
      return ui.voteMap ? Object.keys(ui.voteMap).length : 0;
    }

    // sequential unlocking
    function isUnlockedBattle(i){
      if (i === 0) return true;
      return isVoted(ui.voteMap, i - 1);
    }

    function stoneStateForBattle(i){
      if (isVoted(ui.voteMap, i)) return "completed";
      return isUnlockedBattle(i) ? "unlocked" : "locked";
    }

    function nextUnlockedIndex(){
      return MATCHUPS.findIndex((_, i) => !isVoted(ui.voteMap, i) && isUnlockedBattle(i));
    }

    /* ---------- Path progress fill ---------- */
    function initPathProgress(){
      try{
        if (!els.pathBase || !els.pathProgress) return;
        const len = els.pathBase.getTotalLength();
        ui.pathLen = len;

        els.pathProgress.style.strokeDasharray = `${len} ${len}`;
        els.pathProgress.style.strokeDashoffset = `${len}`; // start empty
      }catch(e){
        // ignore
      }
    }

    function updatePathProgress(){
      if (!els.pathProgress || !ui.pathLen) return;
      const frac = Math.max(0, Math.min(1, voteCount() / MATCHUPS.length));
      const remaining = ui.pathLen * (1 - frac);
      els.pathProgress.style.strokeDashoffset = `${remaining}`;
    }

    function refreshTopProgress(){
      setProgressTextUI(voteCount(), MATCHUPS.length);
      els.mapMiniStatus.textContent = `Completed: ${voteCount()} / ${MATCHUPS.length}`;
      updatePathProgress();
    }

    /* ---------- Arena modal ---------- */
    function openArena(){
      els.arenaModalBack.classList.add("isOpen");
      document.body.style.overflow = "hidden";
    }

    function closeArena(){
      els.arenaModalBack.classList.remove("isOpen");
      document.body.style.overflow = "";
      els.video.pause();
    }

    els.closeArenaBtn.addEventListener("click", closeArena);
    els.arenaModalBack.addEventListener("click", (e) => {
      if (e.target === els.arenaModalBack) closeArena();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && els.arenaModalBack.classList.contains("isOpen")) closeArena();
    });

    /* ---------- Avatar picker modal ---------- */
    function openAvatarModal(){
      els.avatarModalBack.classList.add("isOpen");
      document.body.style.overflow = "hidden";
    }
    function closeAvatarModal(){
      els.avatarModalBack.classList.remove("isOpen");
      document.body.style.overflow = "";
    }

    els.openAvatarBtn.addEventListener("click", openAvatarModal);
    els.closeAvatarBtn.addEventListener("click", closeAvatarModal);
    els.avatarModalBack.addEventListener("click", (e) => {
      if (e.target === els.avatarModalBack) closeAvatarModal();
    });

    /* ---------- Save avatar choice into local progress ---------- */
    function getAvatarId(){
      const p = getLocalProgress?.() || {};
      return p?.monarchWorld?.[SEASON]?.[ROUND_ID]?.avatarId || "lion";
    }

    async function setAvatarId(avatarId){
      await saveProgress((p = {}) => {
        p.monarchWorld ||= {};
        p.monarchWorld[SEASON] ||= {};
        p.monarchWorld[SEASON][ROUND_ID] ||= {};
        p.monarchWorld[SEASON][ROUND_ID].avatarId = avatarId;
        return p;
      });
    }

    function applyAvatarImage(){
      const id = getAvatarId();
      const found = AVATAR_OPTIONS.find(a => a.id === id) || AVATAR_OPTIONS[0];
      els.pathAvatarImg.src = found.src;
    }

    function renderAvatarGrid(){
      els.avatarGrid.innerHTML = "";
      const current = getAvatarId();

      AVATAR_OPTIONS.forEach(a => {
        const card = document.createElement("button");
        card.type = "button";
        card.className = "r1-avatarCard";
        card.innerHTML = `
          <img src="${a.src}" alt="">
          <div class="name">${a.name}${a.id === current ? " ‚úÖ" : ""}</div>
        `;
        card.addEventListener("click", async () => {
          await setAvatarId(a.id);
          applyAvatarImage();
          renderAvatarGrid();
          setStatus(`‚úÖ Avatar selected: ${a.name}`);
          closeAvatarModal();
        });

        els.avatarGrid.appendChild(card);
      });
    }

    /* ---------- Moving avatar logic (correct anchor) ---------- */
    function moveAvatarToIndex(idx, animate = true){
      const slot = ui.stones?.[idx]?.slotEl;
      if (!slot || !els.pathAvatar || !els.battleMap) return;

      // Prefer the actual visible stone element if it exists; fallback to the anchor wrapper.
      const anchor =
        slot.querySelector(".r1-stoneAnchor img") ||
        slot.querySelector(".r1-stoneAnchor svg") ||
        slot.querySelector(".r1-stoneAnchor") ||
        slot;

      if (!animate) els.pathAvatar.style.transition = "none";
      else els.pathAvatar.style.transition = "";

      const mapRect = els.battleMap.getBoundingClientRect();
      const aRect = anchor.getBoundingClientRect();

      const centerX = (aRect.left - mapRect.left) + (aRect.width / 2);
      const centerY = (aRect.top  - mapRect.top)  + (aRect.height / 2);

      els.pathAvatar.style.left = `${centerX}px`;
      els.pathAvatar.style.top  = `${centerY}px`;

      if (!animate) requestAnimationFrame(() => { els.pathAvatar.style.transition = ""; });
    }

    function moveAvatarToNext(animate = true){
      const nextIdx = nextUnlockedIndex();
      const target = nextIdx >= 0 ? nextIdx : (MATCHUPS.length - 1);
      moveAvatarToIndex(target, animate);
    }

    /* ---------- Fireflies ---------- */
    function renderFireflies(){
      els.fireflies.innerHTML = "";
      const count = 14;

      for (let i = 0; i < count; i++){
        const f = document.createElement("div");
        f.className = "r1-firefly";

        const dur = 7 + Math.random() * 7;
        const delay = -(Math.random() * dur);

        const size = 6 + Math.random() * 6;
        f.style.width = `${size}px`;
        f.style.height = `${size}px`;

        f.style.setProperty("--dur", `${dur}s`);
        f.style.setProperty("--delay", `${delay}s`);
        f.style.offsetDistance = `${Math.random() * 100}%`;

        const glowA = 8 + Math.random() * 10;
        const glowB = 16 + Math.random() * 16;
        f.style.boxShadow = `
          0 0 ${glowA}px rgba(255,255,255,0.55),
          0 0 ${glowB}px rgba(251,191,36,0.22)
        `;

        els.fireflies.appendChild(f);
      }
    }

    /* ---------- Map render ---------- */
    function renderBattleMap(){
      els.battleMap.innerHTML = "";
      ui.stones = [];

      const nextIdx = nextUnlockedIndex();

      MATCHUPS.forEach((pair, idx) => {
        const pos = STONE_POS[idx] || { x: 50, y: 50 };

        const slot = document.createElement("div");
        slot.className = "r1-stoneSlot";
        slot.style.left = `${pos.x}%`;
        slot.style.top = `${pos.y}%`;

        const state = stoneStateForBattle(idx);

        if (state === "locked") slot.classList.add("isLocked");
        if (idx === nextIdx) slot.classList.add("isNext");

        const stone = createStepStone({
          assetBase: "../assets",
          state,
          href: "#",
          label: "",
          title: `${idx + 1}`,
          allowCompletedClick: true
        });

        // Anchor wrapper around the stone graphic
        const stoneAnchor = document.createElement("div");
        stoneAnchor.className = "r1-stoneAnchor";
        stoneAnchor.appendChild(stone.root);

        const label = document.createElement("div");
        label.className = "r1-battleLabel";
        label.textContent = `${idx + 1}`;

        if (idx === MATCHUPS.length - 1){
          const badge = document.createElement("span");
          badge.className = "r1-finishBadge";
          badge.textContent = "üèÅ";
          label.appendChild(badge);
        }

        stone.root.addEventListener("click", (e) => {
          e.preventDefault();

          // move avatar to the tapped stone (even if locked)
          moveAvatarToIndex(idx, true);

          if (!isUnlockedBattle(idx) && !isVoted(ui.voteMap, idx)) {
            setStatus(`üîí Complete Battle ${idx} first!`);
            return;
          }

          selectBattle(idx);
        });

        slot.appendChild(stoneAnchor);
        slot.appendChild(label);

        els.battleMap.appendChild(slot);
        ui.stones.push({ slotEl: slot, stoneApi: stone });
      });

      // After stones exist, place avatar on next unlocked
      setTimeout(() => moveAvatarToNext(false), 0);
    }

    /* ---------- Arena logic ---------- */
    function syncArenaLockUI(matchIndex){
      const [a,b] = MATCHUPS[matchIndex];
      const both = hasWatchedBoth(ui.watchedMap, matchIndex, a, b);
      const voted = isVoted(ui.voteMap, matchIndex);

      if (voted){
        setArenaLockTag("‚úÖ Voted");
        els.arenaHint.textContent = "‚úÖ You already voted in this battle (rewatching is allowed).";
      } else if (both){
        setArenaLockTag("‚úÖ Voting unlocked");
        els.arenaHint.textContent = "‚úÖ Voting unlocked! Pick your winner.";
      } else {
        setArenaLockTag("üîí Voting locked");
        els.arenaHint.textContent = "Watch BOTH videos to unlock voting.";
      }

      if (voted) {
        const votedTitle = getVoteForMatch(ui.voteMap, matchIndex);
        if (votedTitle) applyVotedUI({ voteBtnsByTitle: ui.voteBtnsByTitle, votedTitle });
      } else {
        if (both) unlockVoteUI({ voteBtnsByTitle: ui.voteBtnsByTitle });
        else lockVoteUI({ voteBtnsByTitle: ui.voteBtnsByTitle });
      }
    }

    function loadVideoFor(matchIndex, title){
      const url = getVideoUrl2026(title);
      if (!url){
        setStatus(`‚ö†Ô∏è Missing video for: ${title}`);
        return;
      }

      currentMatchIndex = matchIndex;
      currentTitle = title;

      els.video.pause();
      els.video.currentTime = 0;
      els.video.src = url;
      els.video.load();

      els.nowPlaying.textContent = `Now watching: ${title} (Battle ${matchIndex + 1})`;

      const alreadyWatched = hasWatched(ui.watchedMap, matchIndex, title);
      setWatchTag(alreadyWatched ? "‚úÖ Watched (already)" : "üîí Not watched");

      syncArenaLockUI(matchIndex);
    }

    function buildBookCard(containerEl, matchIndex, title){
      containerEl.innerHTML = "";

      const titleEl = document.createElement("div");
      titleEl.className = "r1-bookTitle";
      titleEl.textContent = title;

      const watchedAlready = hasWatched(ui.watchedMap, matchIndex, title);

      const btnRow = document.createElement("div");
      btnRow.className = "r1-btnRow";

      const watchBtn = document.createElement("button");
      watchBtn.className = "mw-btn mw-btn--watch";
      watchBtn.innerHTML = watchedAlready ? `üé• Watch (‚úÖ watched)` : `üé• Watch`;
      watchBtn.addEventListener("click", () => loadVideoFor(matchIndex, title));
      ui.watchBtnsByTitle[title] = watchBtn;

      const voteBtn = document.createElement("button");
      voteBtn.className = "mw-btn mw-btn--vote mw-locked";
      voteBtn.disabled = true;
      voteBtn.textContent = "üîí Vote";

      const [a,b] = MATCHUPS[matchIndex];

      voteBtn.addEventListener("click", async () => {
        if (isVoted(ui.voteMap, matchIndex)) return;

        if (!hasWatchedBoth(ui.watchedMap, matchIndex, a, b)) {
          setStatus("üîí Watch BOTH books in this battle before voting!");
          return;
        }

        await saveVote({
          matchIndex,
          title,
          season: SEASON,
          roundId: ROUND_ID,
          saveProgress
        });

        ui.voteMap = getVoteMap(getLocalProgress, SEASON, ROUND_ID);

        applyVotedUI({ voteBtnsByTitle: ui.voteBtnsByTitle, votedTitle: title });
        confettiBurst({ durationMs: 700, particleCount: 90 });

        // Update stone visuals + unlock next
        renderBattleMap();
        refreshTopProgress();

        // slide avatar to next unlocked
        setTimeout(() => moveAvatarToNext(true), 80);

        const nextNum = matchIndex + 2;
        if (nextNum <= MATCHUPS.length){
          setStatus(`‚úÖ Vote saved! Battle ${nextNum} is now unlocked.`);
        } else {
          setStatus("‚úÖ Vote saved!");
        }

        syncArenaLockUI(matchIndex);

        if (voteCount() === MATCHUPS.length) {
          setStatus("üéâ Round 1 complete! Returning to the main map...");
          setTimeout(() => window.location.href = "../monarchWorld.html", 900);
        }
      });

      ui.voteBtnsByTitle[title] = voteBtn;

      btnRow.appendChild(watchBtn);
      btnRow.appendChild(voteBtn);

      containerEl.appendChild(titleEl);
      containerEl.appendChild(btnRow);
    }

    function renderArena(matchIndex){
      ui.voteBtnsByTitle = {};
      ui.watchBtnsByTitle = {};

      const [a,b] = MATCHUPS[matchIndex];

      els.arenaTitle.textContent = `‚öîÔ∏è Battle Arena ‚Äî ${matchIndex + 1}`;
      els.nowPlaying.textContent = "Choose a book to watch";
      setWatchTag("üîí Not watched");

      buildBookCard(els.bookCardA, matchIndex, a);
      buildBookCard(els.bookCardB, matchIndex, b);

      syncArenaLockUI(matchIndex);

      // reset video when switching battles
      els.video.pause();
      els.video.currentTime = 0;
      els.video.removeAttribute("src");
      els.video.load();

      currentMatchIndex = matchIndex;
      currentTitle = null;

      if (isVoted(ui.voteMap, matchIndex)) {
        setStatus("‚úÖ Already voted here. Close and continue to the next number.");
      } else if (hasWatchedBoth(ui.watchedMap, matchIndex, a, b)) {
        setStatus("‚úÖ Both watched ‚Äî vote is unlocked!");
      } else {
        setStatus("Pick a book. Watch BOTH videos. Then vote!");
      }
    }

    function selectBattle(matchIndex){
      renderArena(matchIndex);
      openArena();
    }

    async function boot(){
      requireLogin(async () => {
        ui.watchedMap = getWatchedMap(getLocalProgress, SEASON, ROUND_ID);
        ui.voteMap = getVoteMap(getLocalProgress, SEASON, ROUND_ID);

        // avatar init
        applyAvatarImage();
        renderAvatarGrid();

        initPathProgress();
        refreshTopProgress();
        renderFireflies();
        renderBattleMap();

        // keep avatar aligned on resize/scroll
        const realign = () => moveAvatarToNext(false);
        window.addEventListener("resize", realign);
        window.addEventListener("scroll", realign, { passive: true });

        attachVideoGate({
          videoEl: els.video,
          getContext: () => ({ matchIndex: currentMatchIndex, title: currentTitle }),
          season: SEASON,
          roundId: ROUND_ID,
          getLocalProgress,
          saveProgress,
          onWatched: ({ matchIndex, title, watchedMap }) => {
            ui.watchedMap = watchedMap;

            const wBtn = ui.watchBtnsByTitle?.[title];
            if (wBtn) wBtn.innerHTML = "üé• Watch (‚úÖ watched)";

            const [a, b] = MATCHUPS[matchIndex];
            const both = hasWatchedBoth(ui.watchedMap, matchIndex, a, b);

            if (both) {
              setWatchTag("‚úÖ Watched ‚Äî BOTH done!");
              if (!isVoted(ui.voteMap, matchIndex)) {
                unlockVoteUI({ voteBtnsByTitle: ui.voteBtnsByTitle });
              }
              setStatus("‚úÖ You watched BOTH books! Now vote for the winner!");
            } else {
              setWatchTag("‚úÖ Watched (one done)");
              setStatus("üëç Nice! Now watch the OTHER book in this battle.");
            }

            syncArenaLockUI(matchIndex);
          }
        });
      });
    }

    boot().catch((err) => {
      console.error(err);
      setStatus("‚ùå Something went wrong. Check the console.");
    });
  </script>
</body>
</html>
