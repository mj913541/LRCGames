<!-- worlds/monarchWorld/rounds/round1.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ü™® Monarch World | Round 1 Path</title>

  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../styles/monarch.css">
  <link rel="stylesheet" href="../styles/animations.css">

  <style>
    body{
      background: url("../assets/backgrounds/night-forest.png") center / cover no-repeat fixed;
    }

    /* --- Round 1 mini-map layout --- */
    .r1-mapWrap{
      position: relative;
      padding: 12px;
      border-radius: 0;
      background: transparent;
      border: none;
      backdrop-filter: none;
      box-shadow: none;
      overflow: hidden;
    }

    .r1-pathCanvas{
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.12;
      z-index: 1;
    }

    .r1-fireflies{
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 2;
      opacity: 0.65;
    }

    .r1-mapArea{
      position: relative;
      height: 720px;
      z-index: 3;
    }

    @media (max-width: 640px){
      .r1-mapArea{ height: 880px; }
    }

    .r1-stoneSlot{
      position: absolute;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0px;
    }

    /* now just a number badge */
    .r1-battleLabel{
      margin-top: -3px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 38px;
      height: 38px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.14);
      background: rgba(255,255,255,0.90);
      font-size: 14px;
      font-weight: 1000;
      box-shadow: 0 10px 22px rgba(0,0,0,0.14);
      user-select: none;
      line-height: 1;
    }

    .r1-selectedRing{
      outline: 4px solid rgba(59,130,246,0.45);
      outline-offset: 6px;
      border-radius: 18px;
    }

    /* ----------------- Fireflies ----------------- */
    .r1-firefly{
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      box-shadow:
        0 0 10px rgba(255,255,255,0.55),
        0 0 22px rgba(251,191,36,0.25);
      opacity: 0.0;

      offset-path: path("M130,620 C240,560 250,470 330,420 C430,360 520,390 600,330 C700,270 690,190 800,160 C900,135 930,80 860,60");
      offset-rotate: 0deg;

      animation:
        r1Fly var(--dur, 8s) linear infinite,
        r1Flicker 1.35s ease-in-out infinite;
      animation-delay: var(--delay, 0s), calc(var(--delay, 0s) * 0.25);
      filter: blur(0.2px);
    }

    @keyframes r1Fly{
      0%   { offset-distance: 0%;   opacity: 0; transform: scale(0.75); }
      8%   { opacity: 0.85; }
      50%  { opacity: 0.95; transform: scale(1); }
      92%  { opacity: 0.85; }
      100% { offset-distance: 100%; opacity: 0; transform: scale(0.75); }
    }

    @keyframes r1Flicker{
      0%,100% { transform: translateY(0) scale(1); opacity: 0.9; }
      50%     { transform: translateY(-2px) scale(0.95); opacity: 0.55; }
    }

    @supports not (offset-path: path("M0,0 L1,1")) {
      .r1-fireflies{ display:none; }
    }

    /* ----------------- Battle Arena Modal ----------------- */
    .r1-modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.58);
      z-index: 80;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
    }
    .r1-modalBack.isOpen{ display:flex; }

    .r1-modal{
      width: min(1100px, 98vw);
      max-height: min(92vh, 920px);
      border-radius: 24px;
      background: rgba(255,255,255,0.93);
      border: 1px solid rgba(0,0,0,0.10);
      backdrop-filter: blur(10px);
      box-shadow: 0 24px 70px rgba(0,0,0,0.30);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }

    .r1-modalHead{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 14px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      flex: 0 0 auto;
    }

    .r1-modalBody{
      padding: 12px 14px 14px;
      overflow: auto;
      flex: 1 1 auto;
    }

    .r1-closeBtn{
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.90);
      border-radius: 999px;
      padding: 8px 10px;
      font-weight: 900;
      box-shadow: 0 8px 18px rgba(0,0,0,0.10);
      user-select:none;
      line-height: 1;
    }
    .r1-closeBtn:hover{ transform: translateY(-1px); }

    .r1-hint{
      font-weight: 900;
      font-size: 13px;
      opacity: 0.85;
    }

    /* NEW: VS layout */
    .r1-vsGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    @media (min-width: 900px){
      .r1-vsGrid{
        grid-template-columns: 1fr;
        gap: 14px;
      }
    }

    .r1-topVsRow{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: stretch;
    }

    @media (min-width: 900px){
      .r1-topVsRow{
        grid-template-columns: 1fr auto 1fr;
        gap: 14px;
        align-items: stretch;
      }
    }

.r1-vsPill{
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight: 1000;
  letter-spacing: 0.14em;
  user-select:none;

  padding: 0;
  border: none;
  background: transparent;
  box-shadow: none;
  border-radius: 0;

  font-size: 26px;
  opacity: 0.95;
  text-shadow: 0 2px 10px rgba(0,0,0,0.25);
  min-width: 52px;
}


    .r1-bioCard{
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 20px;
      background: rgba(255,255,255,0.78);
      box-shadow: 0 12px 26px rgba(0,0,0,0.10);
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
      min-height: 140px;
    }

    .r1-bookTitle{
      font-weight: 1000;
      font-size: 14px;
      line-height: 1.25;
    }

    .r1-btnRow{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .r1-videoSection{
      margin-top: 6px;
    }

    .r1-videoSection .mw-video{
      max-height: 50vh;
    }
  </style>
</head>

<body>
  <div class="mw-shell">

    <!-- HEADER -->
    <div class="mw-card mw-card--soft mw-section mw-animate-fade-up">
      <div class="mw-header">
        <div>
          <div class="mw-title">ü™® Round 1: Battle Path</div>
          <div class="mw-subtitle">
            Tap a stepping stone to open the Battle Arena.
          </div>
        </div>
        <a class="mw-pill" href="../monarchWorld.html">‚Üê Map</a>
      </div>

      <div class="mw-row">
        <div id="progressText" class="mw-status"></div>
        <div id="status" class="mw-status"></div>
      </div>
    </div>

    <!-- MINI MAP -->
    <div class="r1-mapWrap mw-animate-fade-up">
      <div class="flex items-center justify-between gap-3 flex-wrap mb-3 relative" style="z-index:4;">
        <div class="font-extrabold text-lg text-white drop-shadow">üó∫Ô∏è Choose a Battle</div>
        <div class="mw-tag" id="mapMiniStatus">Loading‚Ä¶</div>
      </div>

      <!-- Decorative curved path -->
      <svg class="r1-pathCanvas" viewBox="0 0 1000 700" preserveAspectRatio="none" aria-hidden="true">
        <path
          d="M130,620 C240,560 250,470 330,420
             C430,360 520,390 600,330
             C700,270 690,190 800,160
             C900,135 930,80 860,60"
          fill="none"
          stroke="rgba(255,255,255,0.10)"
          stroke-width="10"
          stroke-linecap="round"
          stroke-dasharray="14 18"
        />
        <path
          d="M130,620 C240,560 250,470 330,420
             C430,360 520,390 600,330
             C700,270 690,190 800,160
             C900,135 930,80 860,60"
          fill="none"
          stroke="rgba(251,191,36,0.025)"
          stroke-width="22"
          stroke-linecap="round"
        />
      </svg>

      <div id="fireflies" class="r1-fireflies" aria-hidden="true"></div>
      <div id="battleMap" class="r1-mapArea"></div>

      <div class="mt-3 text-sm font-bold text-white drop-shadow relative" style="z-index:4;">
        ‚úÖ Completed = you already voted in that battle.
      </div>
    </div>
  </div>

  <!-- BATTLE ARENA MODAL -->
  <div id="arenaModalBack" class="r1-modalBack" role="dialog" aria-modal="true" aria-labelledby="arenaTitle">
    <div class="r1-modal" role="document">
      <div class="r1-modalHead">
        <div class="min-w-0">
          <div id="arenaTitle" class="font-extrabold text-lg">‚öîÔ∏è Battle Arena</div>
          <div id="arenaHint" class="r1-hint">Watch BOTH videos to unlock voting.</div>
          <div class="flex items-center gap-2 flex-wrap mt-2">
            <div class="mw-tag" id="watchTag">üîí Not watched</div>
            <div class="mw-tag" id="arenaLockTag">üîí Voting locked</div>
          </div>
        </div>
        <button id="closeArenaBtn" class="r1-closeBtn" type="button">‚úñ</button>
      </div>

      <div class="r1-modalBody">

        <!-- TOP: two books side-by-side with VS -->
        <div class="r1-topVsRow">

          <div class="r1-bioCard" id="bookCardA"></div>

          <div class="r1-vsPill">VS</div>

          <div class="r1-bioCard" id="bookCardB"></div>

        </div>

        <!-- BOTTOM: video player -->
        <div class="r1-videoSection mt-4">
          <div class="font-extrabold text-lg mb-1">üé• Watch Zone</div>
          <div id="nowPlaying" class="font-bold opacity-80">Choose a book to watch</div>

          <div class="mt-3">
            <video id="video" class="mw-video" controls preload="metadata"></video>
          </div>

          <div class="mt-2 text-sm font-bold opacity-70">
            When the video ends, it counts as watched ‚úÖ
          </div>
          <div id="watchNeed" class="mt-2 text-sm font-bold opacity-70">
            Watch both books in this battle to unlock voting.
          </div>
        </div>

      </div>
    </div>
  </div>

  <script type="module">
    import { requireLogin, getLocalProgress, saveProgress } from "../../../scripts/lrcQuestCore.js";

    import { SEASON } from "../data/nominees-2026.js";
    import { ROUND1_MATCHUPS as MATCHUPS } from "../data/bracket-2026.js";
    import { getVideoUrl2026 } from "../data/video-map-2026.js";

    import { createStepStone } from "../components/stepStone.js";
    import { setProgressText as setProgressTextUI } from "../components/progressBar.js";
    import { attachVideoGate, getWatchedMap, hasWatchedBoth, hasWatched } from "../components/videoGate.js";
    import {
      getVoteMap,
      getVoteForMatch,
      isVoted,
      saveVote,
      applyVotedUI,
      unlockVoteUI,
      lockVoteUI
    } from "../components/voteLock.js";
    import { confettiBurst } from "../components/confetti.js";

    const ROUND_ID = "r1";

    const els = {
      status: document.getElementById("status"),
      progressText: document.getElementById("progressText"),
      mapMiniStatus: document.getElementById("mapMiniStatus"),
      battleMap: document.getElementById("battleMap"),
      fireflies: document.getElementById("fireflies"),

      // Arena modal
      arenaModalBack: document.getElementById("arenaModalBack"),
      closeArenaBtn: document.getElementById("closeArenaBtn"),
      arenaTitle: document.getElementById("arenaTitle"),
      arenaHint: document.getElementById("arenaHint"),
      arenaLockTag: document.getElementById("arenaLockTag"),

      bookCardA: document.getElementById("bookCardA"),
      bookCardB: document.getElementById("bookCardB"),

      nowPlaying: document.getElementById("nowPlaying"),
      watchNeed: document.getElementById("watchNeed"),
      watchTag: document.getElementById("watchTag"),

      video: document.getElementById("video"),
    };

    function setStatus(msg){ els.status.textContent = msg || ""; }
    function setWatchTag(msg){ els.watchTag.textContent = msg || ""; }
    function setArenaLockTag(msg){ els.arenaLockTag.textContent = msg || ""; }

    const ui = {
      watchedMap: {},
      voteMap: {},
      stones: [],
      selectedIndex: null,
      voteBtnsByTitle: {},
      watchBtnsByTitle: {}
    };

    let currentMatchIndex = null;
    let currentTitle = null;

    const STONE_POS = [
      { x: 14, y: 86 },
      { x: 26, y: 78 },
      { x: 33, y: 66 },
      { x: 42, y: 58 },
      { x: 56, y: 55 },
      { x: 64, y: 46 },
      { x: 72, y: 38 },
      { x: 80, y: 30 },
      { x: 88, y: 18 },
      { x: 86, y: 9  }
    ];

    function voteCount(){
      return ui.voteMap ? Object.keys(ui.voteMap).length : 0;
    }

    function refreshTopProgress(){
      setProgressTextUI(voteCount(), MATCHUPS.length);
      els.mapMiniStatus.textContent = `Completed: ${voteCount()} / ${MATCHUPS.length}`;
    }

    function stoneStateForBattle(i){
      return isVoted(ui.voteMap, i) ? "completed" : "unlocked";
    }

    function openArena(){
      els.arenaModalBack.classList.add("isOpen");
      document.body.style.overflow = "hidden";
    }

    function closeArena(){
      els.arenaModalBack.classList.remove("isOpen");
      document.body.style.overflow = "";
      els.video.pause();
    }

    els.closeArenaBtn.addEventListener("click", closeArena);
    els.arenaModalBack.addEventListener("click", (e) => {
      if (e.target === els.arenaModalBack) closeArena();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && els.arenaModalBack.classList.contains("isOpen")) closeArena();
    });

    function renderFireflies(){
      els.fireflies.innerHTML = "";
      const count = 14;

      for (let i = 0; i < count; i++){
        const f = document.createElement("div");
        f.className = "r1-firefly";

        const dur = 7 + Math.random() * 7;
        const delay = -(Math.random() * dur);

        const size = 6 + Math.random() * 6;
        f.style.width = `${size}px`;
        f.style.height = `${size}px`;

        f.style.setProperty("--dur", `${dur}s`);
        f.style.setProperty("--delay", `${delay}s`);
        f.style.offsetDistance = `${Math.random() * 100}%`;

        const glowA = 8 + Math.random() * 10;
        const glowB = 16 + Math.random() * 16;
        f.style.boxShadow = `
          0 0 ${glowA}px rgba(255,255,255,0.55),
          0 0 ${glowB}px rgba(251,191,36,0.22)
        `;

        els.fireflies.appendChild(f);
      }
    }

    function renderBattleMap(){
      els.battleMap.innerHTML = "";
      ui.stones = [];

      MATCHUPS.forEach((pair, idx) => {
        const pos = STONE_POS[idx] || { x: 50, y: 50 };

        const slot = document.createElement("div");
        slot.className = "r1-stoneSlot";
        slot.style.left = `${pos.x}%`;
        slot.style.top = `${pos.y}%`;

        const state = stoneStateForBattle(idx);

        const stone = createStepStone({
          assetBase: "../assets",
          state,
          href: "#",
          label: "",
          title: `${idx + 1}`,  // was "Battle X"
          allowCompletedClick: true
        });

        const label = document.createElement("div");
        label.className = "r1-battleLabel";
        label.textContent = `${idx + 1}`; // JUST THE NUMBER

        stone.root.addEventListener("click", (e) => {
          e.preventDefault();
          selectBattle(idx);
        });

        slot.appendChild(stone.root);
        slot.appendChild(label);

        els.battleMap.appendChild(slot);
        ui.stones.push({ slotEl: slot, stoneApi: stone });
      });
    }

    function highlightSelectedStone(){
      ui.stones.forEach((s, idx) => {
        if (idx === ui.selectedIndex) s.slotEl.classList.add("r1-selectedRing");
        else s.slotEl.classList.remove("r1-selectedRing");
      });
    }

    function syncArenaLockUI(matchIndex){
      const [a,b] = MATCHUPS[matchIndex];
      const both = hasWatchedBoth(ui.watchedMap, matchIndex, a, b);
      const voted = isVoted(ui.voteMap, matchIndex);

      if (voted){
        setArenaLockTag("‚úÖ Voted");
        els.arenaHint.textContent = "‚úÖ You already voted in this battle (rewatching is allowed).";
      } else if (both){
        setArenaLockTag("‚úÖ Voting unlocked");
        els.arenaHint.textContent = "‚úÖ Voting unlocked! Pick your winner.";
      } else {
        setArenaLockTag("üîí Voting locked");
        els.arenaHint.textContent = "Watch BOTH videos to unlock voting.";
      }

      if (voted) {
        const votedTitle = getVoteForMatch(ui.voteMap, matchIndex);
        if (votedTitle) applyVotedUI({ voteBtnsByTitle: ui.voteBtnsByTitle, votedTitle });
      } else {
        if (both) unlockVoteUI({ voteBtnsByTitle: ui.voteBtnsByTitle });
        else lockVoteUI({ voteBtnsByTitle: ui.voteBtnsByTitle });
      }
    }

    function loadVideoFor(matchIndex, title){
      const url = getVideoUrl2026(title);
      if (!url){
        setStatus(`‚ö†Ô∏è Missing video for: ${title}`);
        return;
      }

      currentMatchIndex = matchIndex;
      currentTitle = title;

      els.video.pause();
      els.video.currentTime = 0;
      els.video.src = url;
      els.video.load();

      els.nowPlaying.textContent = `Now watching: ${title} (Battle ${matchIndex + 1})`;

      const alreadyWatched = hasWatched(ui.watchedMap, matchIndex, title);
      setWatchTag(alreadyWatched ? "‚úÖ Watched (already)" : "üîí Not watched");

      syncArenaLockUI(matchIndex);
    }

    function buildBookCard(containerEl, matchIndex, title){
      containerEl.innerHTML = "";

      const titleEl = document.createElement("div");
      titleEl.className = "r1-bookTitle";
      titleEl.textContent = title;

      const watchedAlready = hasWatched(ui.watchedMap, matchIndex, title);

      const btnRow = document.createElement("div");
      btnRow.className = "r1-btnRow";

      const watchBtn = document.createElement("button");
      watchBtn.className = "mw-btn mw-btn--watch";
      watchBtn.innerHTML = watchedAlready ? `üé• Watch (‚úÖ watched)` : `üé• Watch`;
      watchBtn.addEventListener("click", () => loadVideoFor(matchIndex, title));
      ui.watchBtnsByTitle[title] = watchBtn;

      const voteBtn = document.createElement("button");
      voteBtn.className = "mw-btn mw-btn--vote mw-locked";
      voteBtn.disabled = true;
      voteBtn.textContent = "üîí Vote";

      const [a,b] = MATCHUPS[matchIndex];

      voteBtn.addEventListener("click", async () => {
        if (isVoted(ui.voteMap, matchIndex)) return;

        if (!hasWatchedBoth(ui.watchedMap, matchIndex, a, b)) {
          setStatus("üîí Watch BOTH books in this battle before voting!");
          return;
        }

        await saveVote({
          matchIndex,
          title,
          season: SEASON,
          roundId: ROUND_ID,
          saveProgress
        });

        ui.voteMap = getVoteMap(getLocalProgress, SEASON, ROUND_ID);

        applyVotedUI({ voteBtnsByTitle: ui.voteBtnsByTitle, votedTitle: title });
        confettiBurst({ durationMs: 700, particleCount: 90 });

        const s = ui.stones[matchIndex];
        if (s?.stoneApi?.setState) s.stoneApi.setState("completed");

        refreshTopProgress();
        setStatus("‚úÖ Vote saved! Pick another stepping stone!");
        syncArenaLockUI(matchIndex);

        if (voteCount() === MATCHUPS.length) {
          setStatus("üéâ Round 1 complete! Returning to the main map...");
          setTimeout(() => window.location.href = "../monarchWorld.html", 900);
        }
      });

      ui.voteBtnsByTitle[title] = voteBtn;

      btnRow.appendChild(watchBtn);
      btnRow.appendChild(voteBtn);

      containerEl.appendChild(titleEl);
      containerEl.appendChild(btnRow);
    }

    function renderArena(matchIndex){
      ui.voteBtnsByTitle = {};
      ui.watchBtnsByTitle = {};

      const [a,b] = MATCHUPS[matchIndex];

      els.arenaTitle.textContent = `‚öîÔ∏è Battle Arena ‚Äî ${matchIndex + 1}`;
      els.nowPlaying.textContent = "Choose a book to watch";
      setWatchTag("üîí Not watched");

      buildBookCard(els.bookCardA, matchIndex, a);
      buildBookCard(els.bookCardB, matchIndex, b);

      // lock/unlock + voted visuals
      syncArenaLockUI(matchIndex);

      // Reset video when switching battles
      els.video.pause();
      els.video.currentTime = 0;
      els.video.removeAttribute("src");
      els.video.load();

      currentMatchIndex = matchIndex;
      currentTitle = null;

      // Helpful status
      if (isVoted(ui.voteMap, matchIndex)) {
        setStatus("‚úÖ Already voted here. Choose another battle or rewatch.");
      } else if (hasWatchedBoth(ui.watchedMap, matchIndex, a, b)) {
        setStatus("‚úÖ Both watched ‚Äî vote is unlocked!");
      } else {
        setStatus("Pick a book. Watch BOTH videos. Then vote!");
      }
    }

    function selectBattle(matchIndex){
      ui.selectedIndex = matchIndex;
      highlightSelectedStone();

      renderArena(matchIndex);
      openArena();
    }

    async function boot(){
      requireLogin(async () => {
        ui.watchedMap = getWatchedMap(getLocalProgress, SEASON, ROUND_ID);
        ui.voteMap = getVoteMap(getLocalProgress, SEASON, ROUND_ID);

        refreshTopProgress();
        renderFireflies();
        renderBattleMap();

        // Auto-open first incomplete battle (optional). Comment out if you don't want it.
        const firstIncomplete = MATCHUPS.findIndex((_, i) => !isVoted(ui.voteMap, i));
        if (firstIncomplete >= 0) {
          // don't auto-open modal on load; just select highlight
          ui.selectedIndex = firstIncomplete;
          highlightSelectedStone();
        }

        attachVideoGate({
          videoEl: els.video,
          getContext: () => ({ matchIndex: currentMatchIndex, title: currentTitle }),
          season: SEASON,
          roundId: ROUND_ID,
          getLocalProgress,
          saveProgress,
          onWatched: ({ matchIndex, title, watchedMap }) => {
            ui.watchedMap = watchedMap;

            const wBtn = ui.watchBtnsByTitle?.[title];
            if (wBtn) wBtn.innerHTML = "üé• Watch (‚úÖ watched)";

            const [a, b] = MATCHUPS[matchIndex];
            const both = hasWatchedBoth(ui.watchedMap, matchIndex, a, b);

            if (both) {
              setWatchTag("‚úÖ Watched ‚Äî BOTH done!");
              if (!isVoted(ui.voteMap, matchIndex)) {
                unlockVoteUI({ voteBtnsByTitle: ui.voteBtnsByTitle });
              }
              setStatus("‚úÖ You watched BOTH books! Now vote for the winner!");
            } else {
              setWatchTag("‚úÖ Watched (one done)");
              setStatus("üëç Nice! Now watch the OTHER book in this battle.");
            }

            // Refresh lock tag + hint inside modal
            syncArenaLockUI(matchIndex);
          }
        });
      });
    }

    boot().catch((err) => {
      console.error(err);
      setStatus("‚ùå Something went wrong. Check the console.");
    });
  </script>
</body>
</html>
