<!-- worlds/monarchWorld/rounds/round1.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>âš”ï¸ Monarch World | Round 1 Battles</title>

  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../styles/monarch.css">
  <link rel="stylesheet" href="../styles/animations.css">

  <style>
    body{
      background: url("../assets/backgrounds/night-forest.png") center / cover no-repeat fixed;
    }
  </style>
</head>

<body>
  <div class="mw-shell">

    <!-- HEADER -->
    <div class="mw-card mw-card--soft mw-section mw-animate-fade-up">
      <div class="mw-header">
        <div>
          <div class="mw-title">âš”ï¸ Round 1: Battle Arena</div>
          <div class="mw-subtitle">Rule: Watch BOTH book videos all the way to the end, then vote for the winner.</div>
        </div>
        <a class="mw-pill" href="../monarchWorld.html">â† Map</a>
      </div>

      <div class="mw-row">
        <div id="progressText" class="mw-status"></div>
        <div id="status" class="mw-status"></div>
      </div>
    </div>

    <!-- VIDEO ZONE -->
    <div class="mw-card mw-card--soft mw-section mw-animate-fade-up">
      <div class="flex items-center justify-between gap-3 flex-wrap">
        <div>
          <div class="font-extrabold text-lg">ğŸ¥ Watch Zone</div>
          <div id="nowPlaying" class="font-bold opacity-80">Choose a book to watch</div>
          <div id="watchNeed" class="mt-1 text-sm font-bold opacity-70">
            Watch both books in a battle to unlock voting.
          </div>
        </div>
        <div class="mw-tag" id="watchTag">ğŸ”’ Not watched</div>
      </div>

      <div class="mt-3">
        <video id="video" class="mw-video" controls preload="metadata"></video>
      </div>

      <div class="mt-2 text-sm font-bold opacity-70">
        Tip: When the video ends, it counts as watched âœ…
      </div>
    </div>

    <!-- MATCHUPS -->
    <div id="matches" class="mw-arenas mw-animate-fade-up"></div>
  </div>

  <script type="module">
    // âœ… Core (ES module)
    import { requireLogin, getLocalProgress, saveProgress } from "../../../scripts/lrcQuestCore.js";

    // âœ… Data
    import { SEASON } from "../data/nominees-2026.js";
    import { ROUND1_MATCHUPS as MATCHUPS } from "../data/bracket-2026.js";
    import { getVideoUrl2026 } from "../data/video-map-2026.js";

    // âœ… Components
    import { setProgressText as setProgressTextUI } from "../components/progressBar.js";
    import { attachVideoGate, getWatchedMap, hasWatchedBoth, hasWatched } from "../components/videoGate.js";
    import {
      getVoteMap,
      getVoteForMatch,
      isVoted,
      saveVote,
      applyVotedUI,
      unlockVoteUI,
      lockVoteUI
    } from "../components/voteLock.js";
    import { confettiBurst } from "../components/confetti.js";

    const ROUND_ID = "r1";

    const els = {
      status: document.getElementById("status"),
      progressText: document.getElementById("progressText"),
      nowPlaying: document.getElementById("nowPlaying"),
      watchTag: document.getElementById("watchTag"),
      video: document.getElementById("video"),
      matches: document.getElementById("matches")
    };

    function setStatus(msg) { els.status.textContent = msg || ""; }
    function setWatchTag(msg) { els.watchTag.textContent = msg || ""; }

    // UI state
    const ui = {
      // matchIndex -> { card, miniStatusEl, watchBtnsByTitle, voteBtnsByTitle }
      matchCards: {},
      watchedMap: {}, // from progress: watched.m{idx}[title] = true
      voteMap: {}     // from progress: votes.m{idx} = title
    };

    // current video context (for videoGate)
    let currentMatchIndex = null;
    let currentTitle = null;

    function countVotes(voteMap) {
      return voteMap ? Object.keys(voteMap).length : 0;
    }

    function refreshProgressText() {
      setProgressTextUI(countVotes(ui.voteMap), MATCHUPS.length);
    }

    function updateMiniStatus(matchIndex) {
      const group = ui.matchCards[matchIndex];
      if (!group) return;

      const [a, b] = MATCHUPS[matchIndex];
      const watchedA = hasWatched(ui.watchedMap, matchIndex, a);
      const watchedB = hasWatched(ui.watchedMap, matchIndex, b);
      const watchedCount = (watchedA ? 1 : 0) + (watchedB ? 1 : 0);

      const votedTitle = getVoteForMatch(ui.voteMap, matchIndex);
      if (votedTitle) {
        group.miniStatusEl.textContent = "âœ… Voted!";
        return;
      }

      if (watchedCount === 0) group.miniStatusEl.textContent = "Watch both books: 0/2";
      if (watchedCount === 1) group.miniStatusEl.textContent = "Watch both books: 1/2";
      if (watchedCount === 2) group.miniStatusEl.textContent = "âœ… Watched both! Vote unlocked!";
    }

    function loadVideoFor(matchIndex, title) {
      const url = getVideoUrl2026(title);
      if (!url) {
        setStatus(`âš ï¸ Missing video for: ${title}`);
        return;
      }

      currentMatchIndex = matchIndex;
      currentTitle = title;

      els.video.pause();
      els.video.currentTime = 0;
      els.video.src = url;
      els.video.load();

      els.nowPlaying.textContent = `Now watching: ${title} (Battle ${matchIndex + 1})`;

      const alreadyWatched = hasWatched(ui.watchedMap, matchIndex, title);
      setWatchTag(alreadyWatched ? "âœ… Watched (already)" : "ğŸ”’ Not watched");

      const [a, b] = MATCHUPS[matchIndex];
      const both = hasWatchedBoth(ui.watchedMap, matchIndex, a, b);

      if (isVoted(ui.voteMap, matchIndex)) {
        setStatus("This battle is already voted. You can still watch videos!");
      } else if (both) {
        setStatus("âœ… Both watched already â€” vote is unlocked!");
        unlockVoteUI({ voteBtnsByTitle: ui.matchCards[matchIndex].voteBtnsByTitle });
      } else {
        setStatus("Watch BOTH book videos to unlock voting.");
        lockVoteUI({ voteBtnsByTitle: ui.matchCards[matchIndex].voteBtnsByTitle });
      }
    }

    function renderMatches() {
      els.matches.innerHTML = "";
      ui.matchCards = {};

      MATCHUPS.forEach((pair, idx) => {
        const arena = document.createElement("div");
        arena.className = "mw-arena";

        const head = document.createElement("div");
        head.className = "mw-arenaHead";
        head.innerHTML = `
          <div class="mw-arenaTitle">Battle ${idx + 1}</div>
          <div class="mw-tag">${isVoted(ui.voteMap, idx) ? "âœ… Done" : "â­ In Progress"}</div>
        `;
        arena.appendChild(head);

        const miniStatus = document.createElement("div");
        miniStatus.className = "mw-miniStatus";
        arena.appendChild(miniStatus);

        const grid = document.createElement("div");
        grid.className = "mw-bookGrid";

        const watchBtnsByTitle = {};
        const voteBtnsByTitle = {};

        pair.forEach((title) => {
          const block = document.createElement("div");
          block.className = "mw-bookBlock";

          const t = document.createElement("div");
          t.className = "mw-bookTitle";
          t.textContent = title;

          const watchedAlready = hasWatched(ui.watchedMap, idx, title);

          const watchBtn = document.createElement("button");
          watchBtn.className = "mw-btn mw-btn--watch";
          watchBtn.innerHTML = watchedAlready ? `ğŸ¥ Watch (âœ… watched)` : `ğŸ¥ Watch`;
          watchBtn.addEventListener("click", () => loadVideoFor(idx, title));
          watchBtnsByTitle[title] = watchBtn;

          const voteBtn = document.createElement("button");
          voteBtn.className = "mw-btn mw-btn--vote mw-locked";
          voteBtn.disabled = true;
          voteBtn.textContent = "ğŸ”’ Vote";

          voteBtn.addEventListener("click", async () => {
            if (isVoted(ui.voteMap, idx)) return;

            const [a, b] = MATCHUPS[idx];
            if (!hasWatchedBoth(ui.watchedMap, idx, a, b)) {
              setStatus("ğŸ”’ Watch BOTH books in this battle before voting!");
              return;
            }

            // Save + lock
            await saveVote({
              matchIndex: idx,
              title,
              season: SEASON,
              roundId: ROUND_ID,
              saveProgress
            });

            // Refresh local state from localStorage
            ui.voteMap = getVoteMap(getLocalProgress, SEASON, ROUND_ID);

            applyVotedUI({ voteBtnsByTitle, votedTitle: title });
            updateMiniStatus(idx);

            refreshProgressText();
            confettiBurst({ durationMs: 700, particleCount: 90 });

            if (countVotes(ui.voteMap) === MATCHUPS.length) {
              setStatus("ğŸ‰ Round 1 complete! Returning to the map...");
              setTimeout(() => window.location.href = "../monarchWorld.html", 900);
            } else {
              setStatus("âœ… Vote saved! Go to the next battle!");
            }
          });

          voteBtnsByTitle[title] = voteBtn;

          block.appendChild(t);
          block.appendChild(watchBtn);
          block.appendChild(voteBtn);
          grid.appendChild(block);
        });

        arena.appendChild(grid);
        els.matches.appendChild(arena);

        ui.matchCards[idx] = { card: arena, miniStatusEl: miniStatus, watchBtnsByTitle, voteBtnsByTitle };

        // Restore state
        const votedTitle = getVoteForMatch(ui.voteMap, idx);
        if (votedTitle) {
          applyVotedUI({ voteBtnsByTitle, votedTitle });
        } else {
          // unlock votes if both watched
          const [a, b] = MATCHUPS[idx];
          if (hasWatchedBoth(ui.watchedMap, idx, a, b)) unlockVoteUI({ voteBtnsByTitle });
          else lockVoteUI({ voteBtnsByTitle });
        }

        updateMiniStatus(idx);
      });

      refreshProgressText();
    }

    async function boot() {
      // Require login (your core uses callback style)
      requireLogin(async () => {
        // Load state from local progress
        ui.watchedMap = getWatchedMap(getLocalProgress, SEASON, ROUND_ID);
        ui.voteMap = getVoteMap(getLocalProgress, SEASON, ROUND_ID);

        renderMatches();
        setStatus("Pick a battle. Watch BOTH books. Then vote!");

        // Attach watch-to-unlock behavior
        attachVideoGate({
          videoEl: els.video,
          getContext: () => ({ matchIndex: currentMatchIndex, title: currentTitle }),
          season: SEASON,
          roundId: ROUND_ID,
          getLocalProgress,
          saveProgress,
          onWatched: ({ matchIndex, title, watchedMap }) => {
            ui.watchedMap = watchedMap;

            // Update the watch button label
            const wBtn = ui.matchCards?.[matchIndex]?.watchBtnsByTitle?.[title];
            if (wBtn) wBtn.innerHTML = "ğŸ¥ Watch (âœ… watched)";

            updateMiniStatus(matchIndex);

            const [a, b] = MATCHUPS[matchIndex];
            const both = hasWatchedBoth(ui.watchedMap, matchIndex, a, b);

            if (both) {
              setWatchTag("âœ… Watched â€” BOTH done!");
              if (!isVoted(ui.voteMap, matchIndex)) {
                unlockVoteUI({ voteBtnsByTitle: ui.matchCards[matchIndex].voteBtnsByTitle });
              }
              setStatus("âœ… You watched BOTH books! Now vote for the winner!");
            } else {
              setWatchTag("âœ… Watched (one done)");
              setStatus("ğŸ‘ Nice! Now watch the OTHER book in this battle.");
            }
          }
        });
      });
    }

    boot().catch((err) => {
      console.error(err);
      setStatus("âŒ Something went wrong. Check the console.");
    });
  </script>
</body>
</html>
