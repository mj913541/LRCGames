<!-- worlds/monarchWorld/monarchWorld.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ¦‹ Monarch World | Map</title>

  <!-- Tailwind (optional; you can remove later if you prefer pure CSS) -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

  <!-- Your Monarch styles -->
  <link rel="stylesheet" href="./styles/monarch.css">
  <link rel="stylesheet" href="./styles/animations.css">

  <style>
    /* Background for the map page */
    body{
      background: url("./assets/backgrounds/forest-map.png") center / cover no-repeat fixed;
    }
  </style>
</head>

<body>
  <div class="mw-shell">

    <!-- Top Card -->
    <div class="mw-card mw-card--soft mw-section mw-animate-fade-up">
      <div class="mw-header">
        <div>
          <div class="mw-title">ğŸ¦‹ Monarch World ğŸ¦‹</div>
          <div class="mw-subtitle">
            Follow the stepping stones. Watch book videos, then vote to advance!
          </div>
        </div>

        <div class="flex items-center gap-2 flex-wrap">
          <span class="mw-tag" id="userTag">Loadingâ€¦</span>
          <a class="mw-pill" href="../../questHub.html">â† Quest Hub</a>
        </div>
      </div>

      <div class="mw-row">
        <div class="mw-status" id="mapStatus">Checking your progressâ€¦</div>

        <!-- Teacher link appears only for allowed teacher emails -->
        <a id="teacherLink"
           class="mw-pill mw-shimmer"
           href="./teacher/dashboard.html"
           style="display:none;">
          ğŸ‘©â€ğŸ« Teacher Dashboard
        </a>
      </div>
    </div>

    <!-- Map Path -->
    <div class="mw-mapOverlay mw-animate-fade-up">
      <div class="flex items-center justify-between gap-3 flex-wrap mb-3">
        <div class="font-extrabold text-lg">ğŸª¨ Stepping Stones</div>
        <div class="mw-tag" id="seasonTag">Season: 2026</div>
      </div>

      <div id="path" class="mw-path"></div>

      <div class="mt-4 text-sm font-bold opacity-80">
        Tip: A locked stone means the next round hasnâ€™t been unlocked yet.
      </div>
    </div>

  </div>

  <script type="module">
    // Core auth + local progress
    import { requireLogin, getLocalProgress } from "../../scripts/lrcQuestCore.js";

    // Data (season + match count)
    import { SEASON } from "./data/nominees-2026.js";
    import { ROUND1_MATCHUPS } from "./data/bracket-2026.js";

    // Stepstone component
    import { createStepStone } from "./components/stepStone.js";

    // Firestore reads (central season doc)
    import { getFirestore, doc, getDoc } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // Teacher allowlist (you requested only these two)
    const TEACHER_EMAILS = new Set([
      "malbrecht@sd308.org",
      "malbrecht3317@gmail.com"
    ]);

    const els = {
      userTag: document.getElementById("userTag"),
      mapStatus: document.getElementById("mapStatus"),
      seasonTag: document.getElementById("seasonTag"),
      path: document.getElementById("path"),
      teacherLink: document.getElementById("teacherLink")
    };

    const db = getFirestore();

    const DEFAULT_MAP_STATE = {
      unlocked: { r1: true, r2: false, r3: false, final: false },
      completed: { r1: false, r2: false, r3: false, final: false }
    };

    function isTeacherEmail(email) {
      return TEACHER_EMAILS.has(String(email || "").toLowerCase().trim());
    }

    function countKeys(obj) {
      return obj ? Object.keys(obj).length : 0;
    }

    function inferR1CompletedFromLocal(progressObj) {
      // If a student voted in all Round 1 matches, treat as completed for THIS student
      const votes = progressObj?.monarchWorld?.[SEASON]?.r1?.votes || {};
      return countKeys(votes) >= ROUND1_MATCHUPS.length;
    }

    async function loadSeasonDoc(season) {
      // Reads monarchSeasons/{season} created by teacher tool
      const ref = doc(db, "monarchSeasons", season);
      const snap = await getDoc(ref);
      if (!snap.exists()) return null;
      return snap.data() || null;
    }

    function normalizeMapState(fromDoc, localProgress) {
      // Priority:
      // 1) Teacher season doc (global unlocks)
      // 2) Defaults
      const state = structuredClone(DEFAULT_MAP_STATE);

      if (fromDoc?.map?.unlocked) state.unlocked = { ...state.unlocked, ...fromDoc.map.unlocked };
      if (fromDoc?.map?.completed) state.completed = { ...state.completed, ...fromDoc.map.completed };

      // Student-specific completion inference (helpful before teacher generates season doc)
      // Only fill completed.r1 if teacher doc hasn't already marked it.
      if (!state.completed.r1) {
        state.completed.r1 = inferR1CompletedFromLocal(localProgress);
      }

      // If a student completed r1, it makes sense for them to see r2 as unlocked
      // ONLY if the season doc says so; we won't override global locks here.
      return state;
    }

    function renderPath(mapState) {
      els.path.innerHTML = "";

      const items = [
        { key: "r1", label: "Round 1", href: "./rounds/round1.html" },
        { key: "r2", label: "Round 2", href: "./rounds/round2.html" },
        { key: "r3", label: "Round 3", href: "./rounds/round3.html" },
        { key: "final", label: "Final", href: "./rounds/final.html" }
      ];

      items.forEach((it) => {
        const unlocked = !!mapState.unlocked[it.key];
        const completed = !!mapState.completed[it.key];

        const state = completed ? "completed" : (unlocked ? "unlocked" : "locked");

        const stone = createStepStone({
          assetBase: "./assets",
          state,
          href: it.href,
          label: it.label,
          title: unlocked
            ? (completed ? `${it.label} completed` : `${it.label} unlocked`)
            : `${it.label} locked`,
          allowCompletedClick: true
        });

        // Optional: add a small caption under stones
        const wrap = document.createElement("div");
        wrap.className = "flex flex-col items-center";
        wrap.appendChild(stone.root);

        const cap = document.createElement("div");
        cap.className = "mw-stoneCaption";
        cap.textContent = completed ? "âœ… Completed" : (unlocked ? "â­ Ready" : "ğŸ”’ Locked");
        wrap.appendChild(cap);

        els.path.appendChild(wrap);
      });
    }

    function setStatusText(mapState, seasonDocExists) {
      const unlockedCount =
        (mapState.unlocked.r1 ? 1 : 0) +
        (mapState.unlocked.r2 ? 1 : 0) +
        (mapState.unlocked.r3 ? 1 : 0) +
        (mapState.unlocked.final ? 1 : 0);

      const completedCount =
        (mapState.completed.r1 ? 1 : 0) +
        (mapState.completed.r2 ? 1 : 0) +
        (mapState.completed.r3 ? 1 : 0) +
        (mapState.completed.final ? 1 : 0);

      const source = seasonDocExists ? "Teacher season controls are active." : "Using your personal progress (teacher unlocks not found yet).";
      els.mapStatus.textContent = `Unlocked: ${unlockedCount}/4 â€¢ Completed: ${completedCount}/4 â€¢ ${source}`;
    }

    async function boot() {
      els.seasonTag.textContent = `Season: ${SEASON}`;

      requireLogin(async (user) => {
        const email = (user?.email || "").toLowerCase().trim();
        els.userTag.textContent = email ? `Signed in: ${email}` : "Signed in";

        // Show teacher dashboard link only for approved teacher emails
        if (isTeacherEmail(email)) {
          els.teacherLink.style.display = "";
        }

        const localProgress = getLocalProgress() || {};

        let seasonDoc = null;
        try {
          seasonDoc = await loadSeasonDoc(SEASON);
        } catch (e) {
          // If rules block this read, or doc doesn't exist, we fall back safely
          console.warn("Season doc read failed (fallback to local progress).", e);
        }

        const mapState = normalizeMapState(seasonDoc, localProgress);

        renderPath(mapState);
        setStatusText(mapState, !!seasonDoc);
      });
    }

    boot().catch((err) => {
      console.error(err);
      els.userTag.textContent = "âš ï¸ Error";
      els.mapStatus.textContent = "Something went wrong loading the map. Check the console.";
    });
  </script>
</body>
</html>
